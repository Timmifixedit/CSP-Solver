Project for the lecture \char`\"{}\+Objektorientierte Programmierung mit C++\char`\"{} at Ulm University. Solves arbitrary binary constraint satisfaction problems (C\+SP) using the \href{https://en.wikipedia.org/wiki/AC-3_algorithm}{\texttt{ A\+C-\/3 algorithm}} and backtracking search. The seminar paper (German) for this project can be found \href{https://timmifixedit.github.io/CSP-Solver/Report/report.pdf}{\texttt{ here}}.\hypertarget{index_autotoc_md1}{}\doxysubsection{Doxygen Documentation}\label{index_autotoc_md1}

\begin{DoxyItemize}
\item \href{https://timmifixedit.github.io/CSP-Solver/html/index.html}{\texttt{ H\+T\+ML}}
\item \href{https://timmifixedit.github.io/CSP-Solver/CSPSolverDocs.pdf}{\texttt{ P\+DF}}
\end{DoxyItemize}\hypertarget{index_autotoc_md2}{}\doxysubsection{How To}\label{index_autotoc_md2}
A C\+PS consists of a set of variables, represented by {\ttfamily \mbox{\hyperlink{classcsp_1_1Variable}{csp\+::\+Variable}}} and a set of constraints (dependencies between pairs of variables) represented by {\ttfamily \mbox{\hyperlink{classcsp_1_1Constraint}{csp\+::\+Constraint}}} or {\ttfamily \mbox{\hyperlink{classcsp_1_1Arc}{csp\+::\+Arc}}}. You can use your own variable type by deriving from {\ttfamily \mbox{\hyperlink{classcsp_1_1Variable}{csp\+::\+Variable}}}.\hypertarget{index_autotoc_md3}{}\doxysubsubsection{Creating Variables}\label{index_autotoc_md3}
To create a variable, a domain of values has to be given, representing all possible values the variable might take\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include "\mbox{\hyperlink{Variable_8h}{Variable.h}}"}}
\DoxyCodeLine{\textcolor{keyword}{using} MyVar = \mbox{\hyperlink{classcsp_1_1Variable}{csp::Variable<int>}};}
\DoxyCodeLine{MyVar a(\{1, 2, 17, 24\});}
\end{DoxyCode}


Also possible\+: Create your own type. This allows you to add functionality to your variable type. For example, you can add a variable name\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include "\mbox{\hyperlink{Variable_8h}{Variable.h}}"}}
\DoxyCodeLine{\textcolor{keyword}{class }MyVar : \textcolor{keyword}{public} \mbox{\hyperlink{classcsp_1_1Variable}{csp::Variable}}<int> \{}
\DoxyCodeLine{\textcolor{keyword}{public}:}
\DoxyCodeLine{  \textcolor{keyword}{explicit} MyVar(std::string name) : \mbox{\hyperlink{namespacecsp}{csp}}::Variable<int>(\{1, 2, 3, 4\}), name(std::move(name)) \{\}}
\DoxyCodeLine{  \textcolor{keyword}{const} std::string name;}
\DoxyCodeLine{\}}
\end{DoxyCode}
\hypertarget{index_autotoc_md4}{}\doxysubsubsection{Specifying Constraints}\label{index_autotoc_md4}
{\ttfamily \mbox{\hyperlink{classcsp_1_1Constraint}{csp\+::\+Constraint}}} or {\ttfamily \mbox{\hyperlink{classcsp_1_1Arc}{csp\+::\+Arc}}} specify dependencies between pairs of variables. They contain a pointer type to each variable and a binary predicate specifying the constraint. You can use arbitrary pointer types that support the dereference-\/operator as well as -\/$>$ operator. Example using the custom variable type above and shared\+\_\+ptr (which I recommend over raw pointers)\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include "\mbox{\hyperlink{Arc_8h}{Arc.h}}"}}
\DoxyCodeLine{\textcolor{keyword}{auto} varA = std::make\_shared<MyVar>(\textcolor{stringliteral}{"A"});}
\DoxyCodeLine{\textcolor{keyword}{auto} varB = std::make\_shared<MyVar>(\textcolor{stringliteral}{"B"});}
\DoxyCodeLine{\mbox{\hyperlink{classcsp_1_1Constraint}{csp::Constraint}} aLessB(varA, varB, std::less<>());}
\end{DoxyCode}


You can also use {\ttfamily \mbox{\hyperlink{classcsp_1_1Arc}{csp\+::\+Arc}}} to specify the relation between variables. The difference is, that an arc describes a directed constraint. Even if A $<$ B is equivalent to B $>$ A, two arcs describing both relations respectively are not. When defining your C\+SP using arcs, make sure that always both directions are specified explicitly. When using {\ttfamily \mbox{\hyperlink{classcsp_1_1Constraint}{csp\+::\+Constraint}}} only one direction suffices. In some situations, it is easier to specify the C\+SP using arcs than using constraints or vice versa. You cannot mix arcs and constraints when creating a C\+SP but you can convert a {\ttfamily \mbox{\hyperlink{classcsp_1_1Constraint}{csp\+::\+Constraint}}} to two equivalent {\ttfamily \mbox{\hyperlink{classcsp_1_1Arc}{csp\+::\+Arc}}}.\hypertarget{index_autotoc_md5}{}\doxysubsubsection{Creating the C\+SP}\label{index_autotoc_md5}
Once you specified all variables and the respective constraints, create your C\+SP using\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{structcsp_1_1Csp}{csp::Csp}} myCsp = \mbox{\hyperlink{namespacecsp_a5b0c471349dfa5acdd14ead986119ca8}{csp::make\_csp}}(std::array\{varA, varB\}, std::array\{aLessB\});}
\end{DoxyCode}


You can use arbitrary containers that support iteration.\hypertarget{index_autotoc_md6}{}\doxysubsubsection{Solving the C\+SP}\label{index_autotoc_md6}
An instance of {\ttfamily \mbox{\hyperlink{structcsp_1_1Csp}{csp\+::\+Csp}}} can be solved using\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{bool} success = \mbox{\hyperlink{namespacecsp_a2aa8e8d0fa01e590f1bd072968d197bc}{csp::solve}}(myCsp);}
\end{DoxyCode}


If solving the C\+SP is possible all domains of all variables will be reduced to exactly one value. The algorithm will find a solution if one exists (given engough time). If multiple exist, it is unspecified which exact solution is found. If the C\+SP cannot be solved, the function returns {\ttfamily false} but might still modify the variables\textquotesingle{} value domains. \hypertarget{index_autotoc_md7}{}\doxyparagraph{Specifying a Solving Strategy}\label{index_autotoc_md7}
By default, {\ttfamily \mbox{\hyperlink{namespacecsp_a2aa8e8d0fa01e590f1bd072968d197bc}{csp\+::solve}}} uses the minimum remaining values strategy, meaning that the algorithm chooses the variable with the fewest remaining values in its domain to be assigned next. You can also use a different (even custom) strategy e.\+g.\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{auto} strat = [](\textcolor{keyword}{const} \textcolor{keyword}{auto} \& problem) \{}
\DoxyCodeLine{  \textcolor{comment}{// Your code here -\/> return the desired unassigned variable from the CSP}}
\DoxyCodeLine{  \textcolor{keywordflow}{return} theNextVar;}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{bool} success = \mbox{\hyperlink{namespacecsp_a2aa8e8d0fa01e590f1bd072968d197bc}{csp::solve}}(myCsp, strat);}
\end{DoxyCode}


Examples on how to create your own strategy can be found in the file {\ttfamily \mbox{\hyperlink{strategies_8h}{src/strategies.\+h}}}.\hypertarget{index_autotoc_md8}{}\doxysubsection{Solving Sudoku Puzzles}\label{index_autotoc_md8}
The {\ttfamily src/main.\+cpp} contains a program that can solve Sudoku puzzles. A Sudoku is defined by a grid of numbers where a 0 indicates, that the respective field is yet to be assigned. Some examples are provided in the {\ttfamily res} directory. 