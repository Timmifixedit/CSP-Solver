\href{https://github.com/Timmifixedit/CSP-solver/actions/workflows/unit_tests.yml}{\texttt{ }} \hypertarget{index_autotoc_md0}{}\doxysubsection{C\+S\+P-\/\+Solver}\label{index_autotoc_md0}
Project for the lecture \char`\"{}\+Objektorientierte Programmierung mit C++\char`\"{} at Ulm University. Solves arbitrary binary constraint satisfaction problems (C\+SP) using the \href{https://en.wikipedia.org/wiki/AC-3_algorithm}{\texttt{ A\+C-\/3 algorithm}} and backtracking search. The seminar paper (German) for this project can be found \href{https://timmifixedit.github.io/CSP-Solver/Report/report.pdf}{\texttt{ here}}.\hypertarget{index_autotoc_md1}{}\doxysubsubsection{Doxygen Documentation}\label{index_autotoc_md1}

\begin{DoxyItemize}
\item \href{https://timmifixedit.github.io/CSP-Solver/docs/html/index.html}{\texttt{ H\+T\+ML}}
\item \href{https://timmifixedit.github.io/CSP-Solver/docs/CSPSolverDocs.pdf}{\texttt{ P\+DF}}
\end{DoxyItemize}\hypertarget{index_autotoc_md2}{}\doxysubsubsection{How To}\label{index_autotoc_md2}
A C\+PS consists of a set of variables, represented by {\ttfamily \mbox{\hyperlink{classcsp_1_1Variable}{csp\+::\+Variable}}} and a set of constraints (dependencies between pairs of variables) represented by {\ttfamily \mbox{\hyperlink{classcsp_1_1Constraint}{csp\+::\+Constraint}}} or {\ttfamily \mbox{\hyperlink{classcsp_1_1Arc}{csp\+::\+Arc}}}. You can use your own variable type by deriving from {\ttfamily \mbox{\hyperlink{classcsp_1_1Variable}{csp\+::\+Variable}}}.\hypertarget{index_autotoc_md3}{}\doxyparagraph{Creating Variables}\label{index_autotoc_md3}
To create a variable, a domain of values has to be given, representing all possible values the variable might take\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include "\mbox{\hyperlink{csp__solver_8h}{csp\_solver.h}}"}}
\DoxyCodeLine{\mbox{\hyperlink{classcsp_1_1Variable}{csp::Variable}} a\{1, 2, 17, 24\};}
\end{DoxyCode}


A variable can be defined on any domain type. Also, you can change the underlying container used for the domain\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include "\mbox{\hyperlink{csp__solver_8h}{csp\_solver.h}}"}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{\textcolor{keyword}{using} MyVar = \mbox{\hyperlink{classcsp_1_1Variable}{csp::Variable<double, std::vector>}};}
\DoxyCodeLine{MyVar a\{0.2, 4, 1.7\};}
\end{DoxyCode}


The default container used as domain storage is {\ttfamily std\+::list}. This is due to the fact that during solving, values need to be erased from the domain. When your variables have domains with many values, a data storage that supports efficient removal from any position might be advantageous. When your domains only contain a few values (and / or when your values can be copied / moved efficiently), a container like {\ttfamily std\+::vector} or {\ttfamily std\+::deque} which supports efficient iteration might be the better choice.

Furthermore, you can create your own variable type. This allows you to add functionality to your variable type. For example, you can add a variable name\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include "\mbox{\hyperlink{csp__solver_8h}{csp\_solver.h}}"}}
\DoxyCodeLine{\textcolor{keyword}{class }MyVar : \textcolor{keyword}{public} \mbox{\hyperlink{classcsp_1_1Variable}{csp::Variable}}<int> \{}
\DoxyCodeLine{\textcolor{keyword}{public}:}
\DoxyCodeLine{  \textcolor{keyword}{explicit} MyVar(std::string name) : \mbox{\hyperlink{namespacecsp}{csp}}::Variable<int>\{1, 2, 3, 4\}, name(std::move(name)) \{\}}
\DoxyCodeLine{  \textcolor{keyword}{const} std::string name;}
\DoxyCodeLine{\};}
\end{DoxyCode}
\hypertarget{index_autotoc_md4}{}\doxyparagraph{Specifying Constraints}\label{index_autotoc_md4}
{\ttfamily \mbox{\hyperlink{classcsp_1_1Constraint}{csp\+::\+Constraint}}} or {\ttfamily \mbox{\hyperlink{classcsp_1_1Arc}{csp\+::\+Arc}}} specify dependencies between pairs of variables. They contain a pointer type to each variable and a binary predicate specifying the constraint. You can use arbitrary pointer types that support the dereference-\/operator as well as -\/$>$ operator. Example using the custom variable type above and shared\+\_\+ptr (which I recommend over raw pointers)\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include "\mbox{\hyperlink{csp__solver_8h}{csp\_solver.h}}"}}
\DoxyCodeLine{\textcolor{keyword}{auto} varA = std::make\_shared<MyVar>(\textcolor{stringliteral}{"A"});}
\DoxyCodeLine{\textcolor{keyword}{auto} varB = std::make\_shared<MyVar>(\textcolor{stringliteral}{"B"});}
\DoxyCodeLine{\mbox{\hyperlink{classcsp_1_1Constraint}{csp::Constraint}} aLessB(varA, varB, std::less<>());}
\end{DoxyCode}


You can also use {\ttfamily \mbox{\hyperlink{classcsp_1_1Arc}{csp\+::\+Arc}}} to specify the relation between variables. The difference is, that an arc describes a directed constraint. Even if A $<$ B is equivalent to B $>$ A, two arcs describing both relations respectively are not. When defining your C\+SP using arcs, make sure that always both directions are specified explicitly. When using {\ttfamily \mbox{\hyperlink{classcsp_1_1Constraint}{csp\+::\+Constraint}}} only one direction suffices. In some situations, it is easier to specify the C\+SP using arcs than using constraints or vice versa. You cannot mix arcs and constraints when creating a C\+SP but you can convert a {\ttfamily \mbox{\hyperlink{classcsp_1_1Constraint}{csp\+::\+Constraint}}} to two equivalent {\ttfamily \mbox{\hyperlink{classcsp_1_1Arc}{csp\+::\+Arc}}}.\hypertarget{index_autotoc_md5}{}\doxyparagraph{Creating the C\+SP}\label{index_autotoc_md5}
Once you specified all variables and the respective constraints, create your C\+SP using\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{structcsp_1_1Csp}{csp::Csp}} myCsp = \mbox{\hyperlink{namespacecsp_a5b0c471349dfa5acdd14ead986119ca8}{csp::make\_csp}}(std::array\{varA, varB\}, std::array\{aLessB\});}
\end{DoxyCode}


You can use arbitrary containers that support iteration.\hypertarget{index_autotoc_md6}{}\doxyparagraph{Solving the C\+SP}\label{index_autotoc_md6}
An instance of {\ttfamily \mbox{\hyperlink{structcsp_1_1Csp}{csp\+::\+Csp}}} can be solved using\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{bool} success = \mbox{\hyperlink{namespacecsp_a2aa8e8d0fa01e590f1bd072968d197bc}{csp::solve}}(myCsp);}
\end{DoxyCode}


If solving the C\+SP is possible all domains of all variables will be reduced to exactly one value. The algorithm will find a solution if one exists (given engough time). If multiple exist, it is unspecified which exact solution is found. If the C\+SP cannot be solved, the function returns {\ttfamily false} but might still modify the variables\textquotesingle{} value domains. \hypertarget{index_autotoc_md7}{}\doxysubparagraph{Specifying a Solving Strategy}\label{index_autotoc_md7}
By default, {\ttfamily \mbox{\hyperlink{namespacecsp_a2aa8e8d0fa01e590f1bd072968d197bc}{csp\+::solve}}} uses the minimum remaining values strategy, meaning that the algorithm chooses the variable with the fewest remaining values in its domain to be assigned next. You can also use a different (even custom) strategy e.\+g.\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{auto} strat = [](\textcolor{keyword}{const} \textcolor{keyword}{auto} \& problem) \{}
\DoxyCodeLine{  \textcolor{comment}{// Your code here -\/> return the desired unassigned variable from the CSP}}
\DoxyCodeLine{  \textcolor{keywordflow}{return} theNextVar;}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{bool} success = \mbox{\hyperlink{namespacecsp_a2aa8e8d0fa01e590f1bd072968d197bc}{csp::solve}}(myCsp, strat);}
\end{DoxyCode}


Examples on how to create your own strategy can be found in the file {\ttfamily \mbox{\hyperlink{strategies_8h}{src/strategies.\+h}}}.\hypertarget{index_autotoc_md8}{}\doxysubsubsection{Solving Sudoku Puzzles}\label{index_autotoc_md8}
The {\ttfamily src/main.\+cpp} contains a program that can solve Sudoku puzzles. A Sudoku is defined by a grid of numbers where a 0 indicates, that the respective field is yet to be assigned. Some examples are provided in the {\ttfamily res} directory. 