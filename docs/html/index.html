<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CSP-Solver: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CSP-Solver
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">CSP-Solver Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a href="https://github.com/Timmifixedit/CSP-solver/actions/workflows/unit_tests.yml"><object type="image/svg+xml" data="https://github.com/Timmifixedit/CSP-Solver/actions/workflows/unit_tests.yml/badge.svg" style="pointer-events: none;">unit tests</object></a> </p>
<h1><a class="anchor" id="autotoc_md0"></a>
CSP-Solver</h1>
<p>Project for the lecture "Objektorientierte Programmierung mit C++" at Ulm University. Solves arbitrary binary constraint satisfaction problems (CSP) using the <a href="https://en.wikipedia.org/wiki/AC-3_algorithm">AC-3 algorithm</a> and backtracking search. The seminar paper (German) for this project can be found <a href="https://timmifixedit.github.io/CSP-Solver/Report/report.pdf">here</a>.</p>
<h2><a class="anchor" id="autotoc_md1"></a>
Doxygen Documentation</h2>
<ul>
<li><a href="https://timmifixedit.github.io/CSP-Solver/docs/html/index.html">HTML</a></li>
<li><a href="https://timmifixedit.github.io/CSP-Solver/docs/CSPSolverDocs.pdf">PDF</a></li>
</ul>
<h2><a class="anchor" id="autotoc_md2"></a>
How To</h2>
<p>A CPS consists of a set of variables, represented by <code><a class="el" href="classcsp_1_1Variable.html">csp::Variable</a></code> and a set of constraints (dependencies between pairs of variables) represented by <code><a class="el" href="classcsp_1_1Constraint.html">csp::Constraint</a></code> or <code><a class="el" href="classcsp_1_1Arc.html">csp::Arc</a></code>. You can use your own variable type by deriving from <code><a class="el" href="classcsp_1_1Variable.html">csp::Variable</a></code>.</p>
<h3><a class="anchor" id="autotoc_md3"></a>
Creating Variables</h3>
<p>To create a variable, a domain of values has to be given, representing all possible values the variable might take: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="csp__solver_8h.html">csp_solver.h</a>&quot;</span></div>
<div class="line"><a class="code" href="classcsp_1_1Variable.html">csp::Variable</a> a{1, 2, 17, 24};</div>
</div><!-- fragment --><p>A variable can be defined on any domain type. Also, you can change the underlying container used for the domain: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="csp__solver_8h.html">csp_solver.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"><span class="keyword">using</span> MyVar = <a class="code" href="classcsp_1_1Variable.html">csp::Variable&lt;double, std::vector&gt;</a>;</div>
<div class="line">MyVar a{0.2, 4, 1.7};</div>
</div><!-- fragment --><p>The default container used as domain storage is <code>std::list</code>. This is due to the fact that during solving, values need to be erased from the domain. When your variables have domains with many values, a data storage that supports efficient removal from any position might be advantageous. When your domains only contain a few values (and / or when your values can be copied / moved efficiently), a container like <code>std::vector</code> or <code>std::deque</code> which supports efficient iteration might be the better choice.</p>
<p>Furthermore, you can create your own variable type. This allows you to add functionality to your variable type. For example, you can add a variable name: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="csp__solver_8h.html">csp_solver.h</a>&quot;</span></div>
<div class="line"><span class="keyword">class </span>MyVar : <span class="keyword">public</span> <a class="code" href="classcsp_1_1Variable.html">csp::Variable</a>&lt;int&gt; {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">explicit</span> MyVar(std::string name) : <a class="code" href="namespacecsp.html">csp</a>::Variable&lt;int&gt;{1, 2, 3, 4}, name(std::move(name)) {}</div>
<div class="line">  <span class="keyword">const</span> std::string name;</div>
<div class="line">};</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md4"></a>
Specifying Constraints</h3>
<p><code><a class="el" href="classcsp_1_1Constraint.html">csp::Constraint</a></code> or <code><a class="el" href="classcsp_1_1Arc.html">csp::Arc</a></code> specify dependencies between pairs of variables. They contain a pointer type to each variable and a binary predicate specifying the constraint. You can use arbitrary pointer types that support the dereference-operator as well as -&gt; operator. Example using the custom variable type above and shared_ptr (which I recommend over raw pointers): </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;memory&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="csp__solver_8h.html">csp_solver.h</a>&quot;</span></div>
<div class="line"><span class="keyword">auto</span> varA = std::make_shared&lt;MyVar&gt;(<span class="stringliteral">&quot;A&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> varB = std::make_shared&lt;MyVar&gt;(<span class="stringliteral">&quot;B&quot;</span>);</div>
<div class="line"><a class="code" href="classcsp_1_1Constraint.html">csp::Constraint</a> aLessB(varA, varB, std::less&lt;&gt;());</div>
</div><!-- fragment --><p>You can also use <code><a class="el" href="classcsp_1_1Arc.html">csp::Arc</a></code> to specify the relation between variables. The difference is, that an arc describes a directed constraint. Even if A &lt; B is equivalent to B &gt; A, two arcs describing both relations respectively are not. When defining your CSP using arcs, make sure that always both directions are specified explicitly. When using <code><a class="el" href="classcsp_1_1Constraint.html">csp::Constraint</a></code> only one direction suffices. In some situations, it is easier to specify the CSP using arcs than using constraints or vice versa. You cannot mix arcs and constraints when creating a CSP but you can convert a <code><a class="el" href="classcsp_1_1Constraint.html">csp::Constraint</a></code> to two equivalent <code><a class="el" href="classcsp_1_1Arc.html">csp::Arc</a></code>.</p>
<h3><a class="anchor" id="autotoc_md5"></a>
Creating the CSP</h3>
<p>Once you specified all variables and the respective constraints, create your CSP using: </p><div class="fragment"><div class="line"><a class="code" href="structcsp_1_1Csp.html">csp::Csp</a> myCsp = <a class="code" href="namespacecsp.html#a5b0c471349dfa5acdd14ead986119ca8">csp::make_csp</a>(std::array{varA, varB}, std::array{aLessB});</div>
</div><!-- fragment --><p>You can use arbitrary containers that support iteration.</p>
<h3><a class="anchor" id="autotoc_md6"></a>
Solving the CSP</h3>
<p>An instance of <code><a class="el" href="structcsp_1_1Csp.html">csp::Csp</a></code> can be solved using: </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> success = <a class="code" href="namespacecsp.html#a2aa8e8d0fa01e590f1bd072968d197bc">csp::solve</a>(myCsp);</div>
</div><!-- fragment --><p>If solving the CSP is possible all domains of all variables will be reduced to exactly one value. The algorithm will find a solution if one exists (given engough time). If multiple exist, it is unspecified which exact solution is found. If the CSP cannot be solved, the function returns <code>false</code> but might still modify the variables' value domains. </p>
<h4><a class="anchor" id="autotoc_md7"></a>
Specifying a Solving Strategy</h4>
<p>By default, <code><a class="el" href="namespacecsp.html#a2aa8e8d0fa01e590f1bd072968d197bc">csp::solve</a></code> uses the minimum remaining values strategy, meaning that the algorithm chooses the variable with the fewest remaining values in its domain to be assigned next. You can also use a different (even custom) strategy e.g.: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> strat = [](<span class="keyword">const</span> <span class="keyword">auto</span> &amp; problem) {</div>
<div class="line">  <span class="comment">// Your code here -&gt; return the desired unassigned variable from the CSP</span></div>
<div class="line">  <span class="keywordflow">return</span> theNextVar;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> success = <a class="code" href="namespacecsp.html#a2aa8e8d0fa01e590f1bd072968d197bc">csp::solve</a>(myCsp, strat);</div>
</div><!-- fragment --><p>Examples on how to create your own strategy can be found in the file <code><a class="el" href="strategies_8h.html" title="This file contains different variable choosing strategies that can be used to solve a CSP....">src/strategies.h</a></code>.</p>
<h2><a class="anchor" id="autotoc_md8"></a>
Solving Sudoku Puzzles</h2>
<p>The <code>src/main.cpp</code> contains a program that can solve Sudoku puzzles. A Sudoku is defined by a grid of numbers where a 0 indicates, that the respective field is yet to be assigned. Some examples are provided in the <code>res</code> directory. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<div class="ttc" id="aclasscsp_1_1Constraint_html"><div class="ttname"><a href="classcsp_1_1Constraint.html">csp::Constraint</a></div><div class="ttdef"><b>Definition:</b> Arc.h:64</div></div>
<div class="ttc" id="astructcsp_1_1Csp_html"><div class="ttname"><a href="structcsp_1_1Csp.html">csp::Csp</a></div><div class="ttdef"><b>Definition:</b> Csp.h:63</div></div>
<div class="ttc" id="aclasscsp_1_1Variable_html"><div class="ttname"><a href="classcsp_1_1Variable.html">csp::Variable</a></div><div class="ttdef"><b>Definition:</b> Variable.h:22</div></div>
<div class="ttc" id="acsp__solver_8h_html"><div class="ttname"><a href="csp__solver_8h.html">csp_solver.h</a></div><div class="ttdoc">This file contains the solving algorithm for CSPs. It consists of a recursive backtracking search whi...</div></div>
<div class="ttc" id="anamespacecsp_html"><div class="ttname"><a href="namespacecsp.html">csp</a></div><div class="ttdoc">Contains all relevant datastructures and functions for defining and solving a constraint satisfaction...</div><div class="ttdef"><b>Definition:</b> csp_solver.h:19</div></div>
<div class="ttc" id="anamespacecsp_html_a5b0c471349dfa5acdd14ead986119ca8"><div class="ttname"><a href="namespacecsp.html#a5b0c471349dfa5acdd14ead986119ca8">csp::make_csp</a></div><div class="ttdeci">auto make_csp(const VarContainer &amp;variables, const ArcContainer &amp;arcs) -&gt; Csp&lt; std::decay_t&lt; decltype(std::end(arcs), std::end(variables), *std::begin(variables))&gt;&gt;</div><div class="ttdef"><b>Definition:</b> Csp.h:97</div></div>
<div class="ttc" id="anamespacecsp_html_a2aa8e8d0fa01e590f1bd072968d197bc"><div class="ttname"><a href="namespacecsp.html#a2aa8e8d0fa01e590f1bd072968d197bc">csp::solve</a></div><div class="ttdeci">bool solve(Csp&lt; VarPtr &gt; &amp;problem, const Strategy &amp;strategy=Strategy())</div><div class="ttdef"><b>Definition:</b> csp_solver.h:72</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
