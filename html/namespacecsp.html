<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CSP-Solver: csp Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CSP-Solver
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">csp Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Contains all relevant datastructures and functions for defining and solving a constraint satisfaction problem.  
<a href="namespacecsp.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacecsp_1_1strategies"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsp_1_1strategies.html">strategies</a></td></tr>
<tr class="memdesc:namespacecsp_1_1strategies"><td class="mdescLeft">&#160;</td><td class="mdescRight">contains different variable choosing strategies that can be used to solve a CSP. Apart from these strategies, custom strategies can be used. A strategy must return one of the pointers to a variable stored in the given CSP. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecsp_1_1util"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsp_1_1util.html">util</a></td></tr>
<tr class="memdesc:namespacecsp_1_1util"><td class="mdescLeft">&#160;</td><td class="mdescRight">contains utility functions used by the search algorithm <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsp_1_1Arc.html">Arc</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsp_1_1Constraint.html">Constraint</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcsp_1_1Csp.html">Csp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsp_1_1Variable.html">Variable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ad8fcf085f4571634ecbae5958681130c"><td class="memTemplParams" colspan="2"><a id="ad8fcf085f4571634ecbae5958681130c"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad8fcf085f4571634ecbae5958681130c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>BinaryPredicate</b> = std::function&lt; bool(const T &amp;, const T &amp;)&gt;</td></tr>
<tr class="separator:ad8fcf085f4571634ecbae5958681130c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a7c4b7405c9322942b4fd268d19d03267"><td class="memTemplParams" colspan="2">template&lt;typename VarPtr , typename Strategy &gt; </td></tr>
<tr class="memitem:a7c4b7405c9322942b4fd268d19d03267"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecsp.html#a7c4b7405c9322942b4fd268d19d03267">recursiveSolve</a> (<a class="el" href="structcsp_1_1Csp.html">Csp</a>&lt; VarPtr &gt; &amp;problem, const Strategy &amp;strategy)</td></tr>
<tr class="separator:a7c4b7405c9322942b4fd268d19d03267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aa8e8d0fa01e590f1bd072968d197bc"><td class="memTemplParams" colspan="2">template&lt;typename VarPtr , typename Strategy  = strategies::Mrv&lt;VarPtr&gt;&gt; </td></tr>
<tr class="memitem:a2aa8e8d0fa01e590f1bd072968d197bc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecsp.html#a2aa8e8d0fa01e590f1bd072968d197bc">solve</a> (<a class="el" href="structcsp_1_1Csp.html">Csp</a>&lt; VarPtr &gt; &amp;problem, const Strategy &amp;strategy=Strategy())</td></tr>
<tr class="separator:a2aa8e8d0fa01e590f1bd072968d197bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b0c471349dfa5acdd14ead986119ca8"><td class="memTemplParams" colspan="2">template&lt;typename VarContainer , typename ArcContainer , std::enable_if_t&lt; type_traits::is_arc&lt; std::remove_reference_t&lt; decltype(*std::begin(std::declval&lt; ArcContainer &gt;()))&gt;&gt;::value , int &gt; </td></tr>
<tr class="memitem:a5b0c471349dfa5acdd14ead986119ca8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecsp.html#a5b0c471349dfa5acdd14ead986119ca8">make_csp</a> (const VarContainer &amp;variables, const ArcContainer &amp;arcs) -&gt; <a class="el" href="structcsp_1_1Csp.html">Csp</a>&lt; std::decay_t&lt; decltype(std::end(arcs), std::end(variables), *std::begin(variables))&gt;&gt;</td></tr>
<tr class="separator:a5b0c471349dfa5acdd14ead986119ca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09854faeef3daad91bc3e47d662eea13"><td class="memTemplParams" colspan="2">template&lt;typename VarContainer , typename ContraintContainer , std::enable_if_t&lt; type_traits::is_constraint&lt; std::remove_reference_t&lt; decltype(*std::begin(std::declval&lt; ContraintContainer &gt;()))&gt;&gt;::value , int &gt; </td></tr>
<tr class="memitem:a09854faeef3daad91bc3e47d662eea13"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecsp.html#a09854faeef3daad91bc3e47d662eea13">make_csp</a> (const VarContainer &amp;variables, const ContraintContainer &amp;constraints) -&gt; <a class="el" href="structcsp_1_1Csp.html">Csp</a>&lt; std::decay_t&lt; decltype(std::end(constraints), std::end(variables), *std::begin(variables))&gt;&gt;</td></tr>
<tr class="separator:a09854faeef3daad91bc3e47d662eea13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79f98b60bab0c0e9da221974b40e18a6"><td class="memTemplParams" colspan="2">template&lt;typename VarIt , typename ConstrIt , std::enable_if_t&lt; type_traits::is_constraint&lt; std::remove_reference_t&lt; decltype(*std::declval&lt; ConstrIt &gt;())&gt;&gt;::value , int &gt; </td></tr>
<tr class="memitem:a79f98b60bab0c0e9da221974b40e18a6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecsp.html#a79f98b60bab0c0e9da221974b40e18a6">make_csp</a> (VarIt vBegin, VarIt vEnd, ConstrIt cBegin, ConstrIt cEnd) -&gt; <a class="el" href="structcsp_1_1Csp.html">Csp</a>&lt; std::decay_t&lt; decltype(*++cBegin, cBegin==cEnd,++vBegin, vBegin==vEnd, *vBegin)&gt;&gt;</td></tr>
<tr class="separator:a79f98b60bab0c0e9da221974b40e18a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa367d3ee0272c7fe406f0cf892bc3e0d"><td class="memTemplParams" colspan="2">template&lt;typename VarIt , typename ArcIt , std::enable_if_t&lt; type_traits::is_arc&lt; std::remove_reference_t&lt; decltype(*std::declval&lt; ArcIt &gt;())&gt;&gt;::value , int &gt; </td></tr>
<tr class="memitem:aa367d3ee0272c7fe406f0cf892bc3e0d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecsp.html#aa367d3ee0272c7fe406f0cf892bc3e0d">make_csp</a> (VarIt vBegin, VarIt vEnd, ArcIt aBegin, ArcIt aEnd) -&gt; <a class="el" href="structcsp_1_1Csp.html">Csp</a>&lt; std::decay_t&lt; decltype(*++aBegin, aBegin==aEnd,++vBegin, vBegin==vEnd, *vBegin)&gt;&gt;</td></tr>
<tr class="separator:aa367d3ee0272c7fe406f0cf892bc3e0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Contains all relevant datastructures and functions for defining and solving a constraint satisfaction problem. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a5b0c471349dfa5acdd14ead986119ca8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b0c471349dfa5acdd14ead986119ca8">&#9670;&nbsp;</a></span>make_csp() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VarContainer , typename ArcContainer , std::enable_if_t&lt; type_traits::is_arc&lt; std::remove_reference_t&lt; decltype(*std::begin(std::declval&lt; ArcContainer &gt;()))&gt;&gt;::value , int &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto csp::make_csp </td>
          <td>(</td>
          <td class="paramtype">const VarContainer &amp;&#160;</td>
          <td class="paramname"><em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArcContainer &amp;&#160;</td>
          <td class="paramname"><em>arcs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structcsp_1_1Csp.html">Csp</a>&lt;std::decay_t&lt;decltype(
                    std::end(arcs),
                    std::end(variables),
                    *std::begin(variables)
            )&gt;&gt; </td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a CSP from a container of variable-pointer and a container of csp::Arcs </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">VarContainer</td><td>Container-Type containing pointer-types to a type derived of <a class="el" href="classcsp_1_1Variable.html">csp::Variable</a> </td></tr>
    <tr><td class="paramname">ArcContainer</td><td>Container-Type containing csp::Arcs </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">variables</td><td>Container of all variables in the CSP </td></tr>
    <tr><td class="paramname">arcs</td><td>Container of all directed csp::Arcs in the CSP </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structcsp_1_1Csp.html">csp::Csp</a> representing the problem induced by the given variables and arcs </dd></dl>
<dl class="section note"><dt>Note</dt><dd>When using csp::Arcs to specify the constraints, make sure that if you have a constraint e.g. A &lt; B, you specify both csp::Arcs representing A &lt; B and B &gt; A! Otherwise the problem is malformed and may lead to invalid solutions! </dd></dl>

</div>
</div>
<a id="a09854faeef3daad91bc3e47d662eea13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09854faeef3daad91bc3e47d662eea13">&#9670;&nbsp;</a></span>make_csp() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VarContainer , typename ContraintContainer , std::enable_if_t&lt; type_traits::is_constraint&lt; std::remove_reference_t&lt; decltype(*std::begin(std::declval&lt; ContraintContainer &gt;()))&gt;&gt;::value , int &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto csp::make_csp </td>
          <td>(</td>
          <td class="paramtype">const VarContainer &amp;&#160;</td>
          <td class="paramname"><em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContraintContainer &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structcsp_1_1Csp.html">Csp</a>&lt;std::decay_t&lt;decltype(
                    std::end(constraints),
                    std::end(variables),
                    *std::begin(variables)
            )&gt;&gt; </td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a CSP from a container of variable-pointers and a container of csp::Constraints </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">VarContainer</td><td>Container-Type containing pointer-types to a type derived of <a class="el" href="classcsp_1_1Variable.html">csp::Variable</a> </td></tr>
    <tr><td class="paramname">ArcContainer</td><td>Container-Type containing csp::Constraints </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">variables</td><td>Container of all variables in the CSP </td></tr>
    <tr><td class="paramname">arcs</td><td>Container of all undirected csp::Constraints in the CSP </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structcsp_1_1Csp.html">csp::Csp</a> representing the problem induced by the given variables and constraints </dd></dl>
<dl class="section note"><dt>Note</dt><dd>When using csp::Constraints to specify the constraints, specify them only once. A <a class="el" href="classcsp_1_1Constraint.html">csp::Constraint</a> for e.g. A &lt; B fully represents the constraint between the <a class="el" href="classcsp_1_1Variable.html">csp::Variable</a> A and B. Specifying A &lt; B and B &gt; A may lead to performance loss during search! </dd></dl>

</div>
</div>
<a id="aa367d3ee0272c7fe406f0cf892bc3e0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa367d3ee0272c7fe406f0cf892bc3e0d">&#9670;&nbsp;</a></span>make_csp() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VarIt , typename ArcIt , std::enable_if_t&lt; type_traits::is_arc&lt; std::remove_reference_t&lt; decltype(*std::declval&lt; ArcIt &gt;())&gt;&gt;::value , int &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto csp::make_csp </td>
          <td>(</td>
          <td class="paramtype">VarIt&#160;</td>
          <td class="paramname"><em>vBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VarIt&#160;</td>
          <td class="paramname"><em>vEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArcIt&#160;</td>
          <td class="paramname"><em>aBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArcIt&#160;</td>
          <td class="paramname"><em>aEnd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structcsp_1_1Csp.html">Csp</a>&lt;std::decay_t&lt;decltype(*++aBegin, aBegin == aEnd, ++vBegin, vBegin == vEnd, *vBegin)&gt;&gt; </td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a CSP from a container of variable-pointers and a container of <a class="el" href="classcsp_1_1Arc.html">csp::Arc</a> using iterators. Variables and arcs are taken from the respective range [begin, end) </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">VarIt</td><td>Iterator type of variable container </td></tr>
    <tr><td class="paramname">ArcIt</td><td>Iterator type of arc container </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vBegin</td><td>start of range of variables </td></tr>
    <tr><td class="paramname">vEnd</td><td>end of range of variables (exclusive) </td></tr>
    <tr><td class="paramname">aBegin</td><td>start of range of arcs </td></tr>
    <tr><td class="paramname">aEnd</td><td>start of range of arcs (exclusive) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structcsp_1_1Csp.html">csp::Csp</a> representing the problem induced by the given variables and arcs </dd></dl>
<dl class="section note"><dt>Note</dt><dd>When using csp::Arcs to specify the constraints, make sure that if you have a constraint e.g. A &lt; B, you specify both csp::Arcs representing A &lt; B and B &gt; A! Otherwise the problem is malformed and may lead to invalid solutions! </dd></dl>

</div>
</div>
<a id="a79f98b60bab0c0e9da221974b40e18a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79f98b60bab0c0e9da221974b40e18a6">&#9670;&nbsp;</a></span>make_csp() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VarIt , typename ConstrIt , std::enable_if_t&lt; type_traits::is_constraint&lt; std::remove_reference_t&lt; decltype(*std::declval&lt; ConstrIt &gt;())&gt;&gt;::value , int &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto csp::make_csp </td>
          <td>(</td>
          <td class="paramtype">VarIt&#160;</td>
          <td class="paramname"><em>vBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VarIt&#160;</td>
          <td class="paramname"><em>vEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstrIt&#160;</td>
          <td class="paramname"><em>cBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstrIt&#160;</td>
          <td class="paramname"><em>cEnd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structcsp_1_1Csp.html">Csp</a>&lt;std::decay_t&lt;decltype(*++cBegin, cBegin == cEnd, ++vBegin, vBegin == vEnd, *vBegin)&gt;&gt; </td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a CSP from a container of variable-pointers and a container of <a class="el" href="classcsp_1_1Constraint.html">csp::Constraint</a> using iterators. Variables and constraints are taken from the respective range [begin, end) </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">VarIt</td><td>Iterator type of variable container </td></tr>
    <tr><td class="paramname">ConstrIt</td><td>Iterator type of constraint container </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vBegin</td><td>start of range of variables </td></tr>
    <tr><td class="paramname">vEnd</td><td>end of range of variables (exclusive) </td></tr>
    <tr><td class="paramname">cBegin</td><td>start of range of constraints </td></tr>
    <tr><td class="paramname">cEnd</td><td>start of range of constraints (exclusive) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structcsp_1_1Csp.html">csp::Csp</a> representing the problem induced by the given variables and constraints </dd></dl>
<dl class="section note"><dt>Note</dt><dd>When using csp::Constraints to specify the constraints, specify them only once. A <a class="el" href="classcsp_1_1Constraint.html">csp::Constraint</a> for e.g. A &lt; B fully represents the constraint between the <a class="el" href="classcsp_1_1Variable.html">csp::Variable</a> A and B. Specifying A &lt; B and B &gt; A may lead to performance loss during search! </dd></dl>

</div>
</div>
<a id="a7c4b7405c9322942b4fd268d19d03267"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c4b7405c9322942b4fd268d19d03267">&#9670;&nbsp;</a></span>recursiveSolve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VarPtr , typename Strategy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool csp::recursiveSolve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcsp_1_1Csp.html">Csp</a>&lt; VarPtr &gt; &amp;&#160;</td>
          <td class="paramname"><em>problem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Strategy &amp;&#160;</td>
          <td class="paramname"><em>strategy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Recursive backtracking search for csp::Csps. Prefer using the wrapper function <a class="el" href="namespacecsp.html#a2aa8e8d0fa01e590f1bd072968d197bc">csp::solve</a> </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">VarPtr</td><td>Pointer-type to a type derived from <a class="el" href="classcsp_1_1Variable.html">csp::Variable</a> </td></tr>
    <tr><td class="paramname">Strategy</td><td>Type of value selection strategy during search </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">problem</td><td>CSP to be solved </td></tr>
    <tr><td class="paramname">strategy</td><td>value selection strategy object used during during search </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if problem was solved, false otherwise </dd></dl>

</div>
</div>
<a id="a2aa8e8d0fa01e590f1bd072968d197bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2aa8e8d0fa01e590f1bd072968d197bc">&#9670;&nbsp;</a></span>solve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VarPtr , typename Strategy  = strategies::Mrv&lt;VarPtr&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool csp::solve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcsp_1_1Csp.html">Csp</a>&lt; VarPtr &gt; &amp;&#160;</td>
          <td class="paramname"><em>problem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Strategy &amp;&#160;</td>
          <td class="paramname"><em>strategy</em> = <code>Strategy()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Solves a CSP. If a solution exists, the value domains of each variable in the given <a class="el" href="structcsp_1_1Csp.html">Csp</a> will be reduced to exactly one value. If multiple solutions exist, it is unspecified which is found. If no solution exists, false is returned but the value domains of the variables might still be altered </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">VarPtr</td><td>Pointer-type to a type derived from <a class="el" href="classcsp_1_1Variable.html">csp::Variable</a> </td></tr>
    <tr><td class="paramname">Strategy</td><td>Type of value selection strategy during search (default: minimum remaining values strategy). Has to provide ()-Operator and return VarPtr from given <a class="el" href="structcsp_1_1Csp.html">csp::Csp</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">problem</td><td>CSP to be solved </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if problem was solved, false otherwise </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
